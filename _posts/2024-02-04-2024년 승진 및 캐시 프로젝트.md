---
layout: post
title: 2024년 승진 및 캐시 프로젝트
date: 2024-02-04 00:00:00 +0900
description: 배치 처리를 위한 Arehs를 만들다.
img: 2024-02-04/image.png
tags: [승진, 캐시, 레디스, promotion, cache, redis]
---

![promotion]({{site.baseurl}}/assets/img/2024-02-04/promotion.jpg)

2023년 말에 성과를 인정 받아 아시아 태평양(APAC) 지역 소속에서 승진자 중 한명으로 선정되었다.

**2023년 주요 성과 내용**

- NodeJS 18 업그레이드 및 Github Monorepo Repository 분리 작업 주도
- NestJS 프레임워크를 사내용 커스텀 및 래핑하여 깃허브 템플릿으로 제공
- Core library localization(사내 코어 라이브러리 타입스크립트 전환 및 업그레이드 작업)
- Global AI Hackathon(Asurion 북미,유럽,아시아 및 전세계 개발팀 등) 참여
- 한국 비즈니스를 위한 다양한 프로젝트 참여 등

2024년 초 좋은 소식인 승진과 더불어 매니저와 나의 Goals & Objectives를 위한 목표를 설정하였다.  
올해 초 목표 중 하나는 레거시 시스템의 비즈니스 로직에 캐시 코드를 결합하지 않고, 캐시할 수 있는 로우 레벨 캐시 레이어를 만드는 것이 나의 올해 프로젝트 중 하나였다.  
예를 들어 디바이스 재고 서버가 캐시 관련한 로직을 담고 있지 않지만, 모든 것이 자동으로 캐싱되고 높은 고가용성을 보여줄 수 있게 해야한다.

### 예제 코드

`getDeviceByUser` 함수를 실행하면 레디스에 USER_DEVICE_KEY를 저장하고, 3600(초)인 1시간동안 캐싱한다.

```typescript
@RedisCache({ key: RedisKeys.USER_DEVICE_KEY, ttl: 3600 })
  async getDeviceByUser(requestUserDto: RequestUserDto) {
    const param: Query = {
        sql: findDeviceByUserId,
        item: requestUserDto
      };
    const userDevice = await this.userRepository.findDeviceByUser(param);

    return Builder<UserDevice>()
			.device(userDevice.id)
			.userId(userDevice.userId)
			.device(userDevice.data)
      .build();
  }
```

### `@RedisCache`

코드를 좀 더 설명하면 리플렉션으로 실행 중 인 클래스를 호출하여 캐싱을 위한 커스텀 어노테이션 만들었다.  
이것은 주어진 옵션(key, ttl)을 받아 캐싱을 위한 NestJS 커스텀 어노테이션을 생성한다.  
클래스의 메서드에 적용되어 메서드의 실행 결과를 캐싱하고, 캐시된 결과를 반환하거나 업데이트하는 역할을 한다.  
**어노테이션을 통해 로직의 관심사를 분리하여 비즈니스 로직과 레디스 캐시 로직이 직접 결합하지 않아 동료 개발자에게 비즈니스 로직에 집중**할 수 있게 하였다.

그리고 보험 청구 시스템은 여러 시스템 간의 데이터 연동과 검증 작업을 포함하며, 이러한 작업은 몇 초에서 몇 분까지 걸릴 수 있어 모든 데이터를 실시간으로 처리하는 것은 비효율적일 수 있다.  
이를 해결하기 위해 **Hard TTL**과 **Soft TTL**을 활용하여 서버가 다운되더라도 일정 시간 동안 캐시된 데이터를 제공해 시스템의 안정성을 유지한다. 고객이 반복적으로 같은 정보를 조회하는 경우, 캐시된 데이터를 우선 제공함으로써 서버 부하를 줄이고 응답 속도를 높일 수 있다.  
특히, 고객이 확인하는 상태 정보는 대부분 큰 변화가 없는 경우가 많아 약간의 지연을 허용하더라도 문제되지 않는다. 이로 인해 고객 만족도가 향상될 수 있게 되었다.

| 구분          | Hard TTL                         | Soft TTL                                 |
| ------------- | -------------------------------- | ---------------------------------------- |
| **정의**      | 설정된 만료 시간에 정확히 만료됨 | 설정된 만료 시간이 지나도 잠시 유예 가능 |
| **구현 위치** | Redis 기본 제공                  | 애플리케이션 레벨에서 구현               |
| **장점**      | 데이터 정확성이 높음             | 캐시 재생성 부하 감소                    |
| **단점**      | 대량 만료 시 성능 저하 가능      | 데이터 정확성 저하 가능                  |
| **사용 시점** | 실시간 데이터 만료가 중요할 때   | 캐시 갱신 부하를 줄이고 싶을 때          |

## 요약

1. 캐시를 통해 데이터를 메모리 layer에 저장하면 데이터베이스에 대한 쿼리 횟수가 줄어들어 데이터베이스의 부하가 감소하였다.
2. 이로 인해 쿼리 조회 시 값 비싼 디바이스 재고 서버의 성능이 향상되고 응답 시간을 단축 시켰다.
3. 레거시 시스템의 비즈니스 로직과 캐싱 로직이 직접 결합하지 않아 동료들에게 비즈니스 로직에 집중할 수 있게 하였다.
4. 캐시가 필요한 지점에 자동으로 캐싱하여 시스템 성능 향상을 향상시켰다.
